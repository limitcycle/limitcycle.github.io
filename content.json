{"pages":[],"posts":[{"title":"使用Keycloak保護Spring Boot REST服務","text":"對於任何應用程序，安全性始終是主要的跨領域關注點。傳統上，我們過去在整體後端服務中只有一個安全層來保護所有前端應用程序請求。隨著新興的微服務架構的發展，不再有單一的後端服務。前端應用程序調用多個後端服務，這些服務又可以調用其他服務。不再有可以處理身份驗證的單層。由於微服務都具有許多較小的服務，每個服務都處理一個不同的職責，因此安全性的明顯解決方案是身份驗證和授權服務。這是Keycloak進行救援的地方，因為它提供了保護微服務所需的功能。 什麼是KeycloakKeycloak是Red Hat贊助的開源身份和訪問管理（IAM）解決方案。它使我們能夠保護各種現代的前端應用程序和後端服務。Keycloak可以毫不費力地為我們的應用程序和服務添加身份驗證和授權。我們不需要處理用戶的存儲或身份驗證，因為所有這些都可以在Keycloak中直接使用。 Keycloak提供的功能包括單點登錄（SSO），身份代理和社交登錄，用戶聯合，客戶端適配器，管理員和用戶帳戶管理控制台。 除了這些基本功能，Keycloak在其他IAM解決方案中脫穎而出的原因還在於其可定制的網頁和電子郵件模板主題，以及可擴展的功能和領域。可定制的主題很重要，因為它們使開發人員可以定制面向最終用戶的網頁的外觀，以便可以將其與應用程序緊密集成。Keycloak還提供了擴展其核心功能和範圍的功能。這包括可能： 將自定義REST端點添加到Keycloak服務器 添加 Server Provider Interface(SPI) 將自定義 Java Persistence API(JPA)實體添加到Keycloak數據模型中 設置Keycloak以下安裝並運行Keycloak服務器 先確保要運行的機器有OpenJDK1.8或更高的版本 Keycloak官方網站下載最新的Keycloak realease版本 windows 1bin\\standalone.bat linux 1bin/standalone.sh Keycloak默認使用H2資料庫儲存數據，位於standalone/data目錄中。 此資料庫並不適用於Production環境，Keycloak官方強烈建議我們將其替換為更利於Productio環境的外部數據庫，例如PostgreSQL。 可以從官方文檔中獲取有關設置Keycloak數據庫的更多詳細信息。 建立初始化Admin UserKeycloak不附帶初始admin用戶，這意味著在開始使用Keycloak之前，您需要創建一個admin用戶。 打開http://localhost:8080/auth並填寫創建初始管理表單，用戶名為admin，密碼為password。 單擊創建並進入admin console，然後使用剛剛創建的admin登錄。 登錄後Keycloak顯示的第一個屏幕是Master Realm詳細信息。 Keycloak中的realm就像一個容器，其中包含並隔離user、role、group和client的集合。 Keycloak帶有一個預先創建的Master realm。 建議不要使用Master realm管理組織中user和application。 創建和管理其他realm，為admin保留對Master realm的使用。 建立Realms我們將需要一個realm來管理我們的Spring Boot REST服務使用的user，role和client。 因此，讓我們建立第一個realm。 將鼠標懸停在左上角顯示”Master”的下拉菜單上，然後單擊”Add realm”按鈕。 我們將第一個realm命名為demo： 點擊create，將會被定向到創建的realm詳細信息頁面，可以在這進一步配置realm。 建立Rolesrole對user進行分類。在應用程序中，訪問資源的權限通常授予role而不是user。 Admin、User和Manager都是組織中可能存在的典型角色。 要建立role，請單擊左側的”Roles”，然後點擊頁面上的”Add Role”按鈕。 我們將role命名為spring-user，然後點擊save。 建立Users建立User基本資料單擊左側的”Users”，然後點擊”Add User”按鈕。 將username填寫為Steven(登入的account)，將First Name填寫為Steven，並保留其他所有默認設置。 確保”User Enabled”為”on”。點擊save建立第一個user 為User設置密碼Steven需要密碼才能登錄Keycloak，所以需要為Steven創建一個密碼。 點擊”Credentials”標籤，然後在密碼和確認密碼輸入mypassword。 且設置Temporary為OFF，以便在下次登錄時無需更改密碼。 點擊”Set Password”以保存Steven的密碼憑證。 分配Role給User將之前創建的role: spring-user分配給Steven。 為此，請點擊”Role Mappings”選項，選擇spring-user角色，然後點擊”Add Selected”。 建立ClientsClient基本資料建立 Clients are entities that will request the authentication of a user. Client有兩種形式。 第一種類型的Client是想要參與SSO的應用程式，這些Client只希望Keycloak為他們提供安全性。 另一種Client是請求訪問令牌的Client，以便它可以代表已認證的用戶調用其他服務。 我們將創建一個Client用於保護我們的Spring Boot REST服務。 點擊左側的”Clients“，然後點選”Create“。 在表單中，將Client Id填寫為spring-boot，為Client Protocol選擇OpenID Connect，接著點選Save。 更改Access Type及Authorization Enabled在Client的Settings頁面中，我們需要將Access Type更改為confidential，而不是默認的public(不需要Client Secret)。存檔之前，請打開”Authorization Enabled“開關。 Client Secret在Client的Credentials頁面中，先將Secret內容複製出來，下面內容會使用到 拿取Access TokenClient通過使用HTTP POST方法向Keycloak中的Token endpoint發出Token交換請求來請求安全令牌。 1/auth/realms/{realm}/protocol/openid-connect/token Keycloak中的Token交換請求是IETF上OAuth 2.0Token交換規範的寬鬆實現。 OpenID Connect Token endpoint 上的簡單授予類型調用。 Keycloak使用”application/x-www-form-urlencoded“格式和UTF-8字符編碼來接受HTTP請求實體中的參數。 打開Postman，建立對http://localhost:8080/auth/realms/demo/protocol/openid-connect/token POST請求 會收到帶有Access Token和Refresh Token以及其他附帶詳細信息的JSON Response。 將接收到的Access Token作為Bearer Token放置在Authorization Header中，就可以在受到Keycloak安全保護的REST API進行請求: 123headers: { 'Authorization': 'Bearer ' + {access_token} } 從Keycloak的Admin console中，進到spring-boot的Client詳細資訊，然後點選”Sessions“選項。您將看到Steven的登錄session。 點擊Steve進到User詳細資訊，然後點選”Sessions”選項。在”Sessions”選項卡下，有一些選項可用於註銷特定會話或註銷所有會話。 我們已經配置了Keycloak並能夠通過Postman請求Access Token，下一步是創建Spring Boot REST服務並使用Keycloak保護它。 建立一個Spring Boot應用程序使用Spring Initializr網站生成具有Spring Boot 2.x依賴項的項目。還需要Spring Boot Starter Web 模塊 接下來，創建一個@RestController MessagingRestController Class，該Class將getMessage()方法公開為/user/message上的HTTP GET請求。此方法將返回”Hello, User”字串。 12345678@RestControllerpublic class MessagingRestController { @GetMapping(path = &quot;/user/message&quot;) public String getUserMessage() { return &quot;Hello, User&quot;; }} application.yaml中配置server.port 12server: port: 8000 現在我們的REST服務已經可以運行了，我們需要使用Keycloak保護它。 使用Keycloak保護Spring Boot REST服務為了保護您的Spring Boot REST服務，必須將Spring Boot的Keycloak Adpater添加到服務中。 build.gradle 12345678910111213ext { set('keycloakVersion', '12.0.1')}dependencyManagement { imports { mavenBom &quot;org.keycloak.bom:keycloak-adapter-bom:${keycloakVersion}&quot; }}dependencies { implementation 'org.keycloak:keycloak-spring-boot-starter'} 接著將keycloak相關內容配置到application.yml 1234567keycloak: auth-server-url: http://localhost:8080/auth realm: demo resource: spring-boot credentials: secret: 86ef845e-735a-42aa-84c7-fac294c359ad bearer-only: true auth-server-url: Keycloak服務器的URL realm: 在keycloak所建立的realm resource: 在keycloak所建立的Client Id secret: 在keycloak所建立的Client Secret only-bearer-only: 必須為true，以便Adpater不會嘗試對用戶進行身份驗證，而僅驗證Access Token 再讓我們為應用程式增加security-constraints(安全性約束)。此配置非常重要，因為Keycloak Adapter將根據我們的配置允許或拒絕對我們資源的訪問請求 下列例子為: 確保對URL:/user/*的每個請求，僅在該請求的用戶是具有spring-user角色的已認證用戶時才被授權使用。 12345678keycloak: security-constraints: - auth-roles: - spring-user security-collections: - name: patterns: - /user/* 在運行服務之前，讓我們打開Keycloak的DEBUG日誌記錄級別，以在console中查看更多詳細信息。 123logging: level: org.keycloak: TRACE Test HTTP GET User MessageRole spring-user打開postman，URL輸入http://localhost:8000/user/message，HTTP Method為GET再點擊”Authorization”標籤，然後選擇Bearer Token，將之前如下圖示中response的access_token貼上Token欄位裡。 使用者Steven驗證 將上圖的access_token，貼入下圖Token欄位中 點選”Send”過後，會收到 “Hello, User” response 在Console中，會看到keycloak日誌紀錄 Role spring-admin我們將使用新role和user對Keycloak進行更多配置，以演示我們為其他請求URL定義安全約束。 回到keycloak admin console，建立一個新的Role: spring-admin 建立新的User: Dave並設置密碼，且授予spring-admin角色 回到spring應用程式中，建立一個getAdminMessage endpoint 1234@GetMapping(path = &quot;/admin/message&quot;)public String getAdminMessage() { return &quot;Hello, Admin&quot;;} 最後，向我們的應用程序添加另一個安全約束，以授權具有spring-admin角色的用戶訪問URL /admin/*請求。 123456789101112131415keycloak: security-constraints: - auth-roles: - spring-user security-collections: - name: patterns: - /user/* - auth-roles: - spring-admin security-collections: - name: patterns: - /user/* - /admin/* 現在我們使用Steven的token對/admin/message進行請求 此請求被拒絕，因為我們尚未授予spring-user角色訪問請求/admin/*的權限。 讓我們換回用Dave的token，來對/admin/message進行請求，將能成功進行請求 結論 了解到Keycloak是一個現代的身份和訪問管理系統，提供了許多現成的功能。 還學習瞭如何使用realm、role、User和Client來設置Keycloak。 最後，我們學習如何配置Spring Boot REST服務以利用Keycloak認證和授權所有請求。 參考資料 https://codeburst.io/securing-spring-boot-rest-services-using-keycloak-without-writing-code-7c47ab72fb9d","link":"/2021/01/09/spring-boot-with-keycloak/"},{"title":"Keycloak授權服務","text":"上一篇詳細介紹了如何在Spring boot中集成Keycloak來進行應用程式的認證，將認證與授權從業務抽離出來，減少了代碼的撰寫，但在實際的生產環境中，僅僅進行認證服務肯定是不夠的，還需要授權功能。這一篇文章將介紹keycloak對服務所支援的授權功能 keycloak所支援的授權策略Keycloak支持細粒度的授權策略(authorization policies)，並可以對這些策略進一步組合，例如： Attribute-based access control (ABAC): 基於屬性的安全控制 Role-based access control (RBAC): 基於角色的安全控制 User-based access control (UBAC): 基於用戶的安全控制 Context-based access control (CBAC): 基於上下文的安全控制 Rule-based access control: 基於規則的安全控制 Using JavaScript Time-based access control: 基于時間的安全控制 Support for custom access control mechanisms (ACMs) through a Policy Provider Service Provider Interface (SPI): 通過SPI自定義訪問控制策略(ACMs) Keycloak提供了創建受保護資源和範圍權限的必要方法，將這些權限(permissions)與授權策略(authorization policies)相關聯，並在應用程序和服務中實施授權決策。 對於基於RESTful的資源服務器，該信息通常是從安全令牌中獲得的，通常是在每次向服務器請求時作為承載令牌發送的。 對於依賴會話來認證用戶的Web應用程序，該信息通常存儲在用戶會話中，並針對每個請求從該會話中檢索。 資源服務器通常執行的是基於角色的訪問控制(RBAC)策略，即檢查用戶所擁有的角色是否關聯了要訪問的資源。雖然這種方式非常有用，但是它們也有一些限制： 資源和角色緊密耦合，角色的更改（如添加、刪除或更改訪問上下文）可能影響多個資源。 基於RBAC的應用程序無法很好地響應安全性需求的調整。 項目規模擴大時，覆雜的角色管理會很困難而且容易出錯。 不夠靈活。角色並不能有效代表用戶身份，即缺乏上下文信息。客觀上來說被授予了角色的用戶，至少會擁有某些訪問權限。 時至今日，我們需要考慮異構環境，即用戶分佈在不同區域，使用不同的本地策略，使用不同的設備以及對信息共享的需求很高，Keycloak授權服務可以幫助您提高應用程序和服務的授權能力通過提供： 不同的訪問控制機制以及細粒度的授權策略。 集中式的資源、權限以及策略管理。 集中式的策略決策。 REST風格的授權服務。 授權工作流程和用戶訪問管理。 可作為快速響應您項目中安全需求的基礎設施。 Keycloak授權架構從設計的角度來看，授權服務基於一組定義良好的授權模式，它們提供以下功能: 策略管理點(PAP)提供基於Keycloak管理控制台的一組UI，以管理資源服務器，資源，範圍，權限和策略。通過使用Protection API可以部分完成此操作 政策決策點(PDP)提供一個可分配的策略決策點，指向授權請求發送到的位置，並根據請求的權限對策略進行相應的評估。有關更多信息，請參見Obtaining Permissions。 政策執行點(PEP)提供針對不同環境的實現，以在資源服務器端實際執行授權決策。Keycloak提供了一些內置的Policy Enforcer。 政策信息點(PIP)基於Keycloak Authentication Server，您可以在評估授權策略時從身份和運行時環境中獲取屬性。 Keycloak授權流程主要步驟為三個流程，以了解如何使用Keycloak為應用程序啟用細粒度授權: 資源管理(Resource Management) 權限和政策管理(Permission and Policy Management) 政策執行(Policy Enforcement) 資源管理(Resource Management)首先需要指定Keycloak希望保護的內容，通常代表Web應用程序或一組一個或多個服務。使用Keycloak管理控制台管理資源服務器。在那裡，可以啟用任何已注冊的客戶端應用程序作為資源服務器，並開始管理要保護的資源和範圍。 資源可以是網頁，RESTFul資源，文件系統中的文件，EJB等。它們可以表示一組資源(就像Java中的class一樣)，也可以表示單個特定資源。 例如某個用戶能訪問或控制某個區域的設備，區域和設備等都可以看作是資源。範圍(scope)通常表示可以對資源執行的操作，但它們不限於此。還可以使用範圍來表示資源中的一個或多個屬性。 權限和政策管理(Permission and Policy Management)定義資源服務器和要保護的所有資源後，必須設置權限(permissions)和政策(policies)。**(重要)** 此過程涉及實際定義管理資源的安全性和訪問要求的所有必要步驟。政策定義了訪問或執行某些操作(資源或範圍)必須滿足的條件，此部份是通用的，可以重用來構建權限甚至更覆雜的策略。 Keycloak提供了一些內建的政策，比如基於Role的，基於Group的，或者基於User的政策，涵蓋了最常見的訪問控制機制。您甚至可以根據使用JavaScript編寫的規則創建政策。 定義政策後，即可開始定義權限，權限又與要保護的資源相結合。此處指定要保護的內容(資源或範圍)以及授予或拒絕權限必須滿足的政策。 後面會有詳細的例子介紹如何創建使用。 政策執行(Policy Enforcement)政策實施涉及必要的步驟，以實際對資源服務器實施授權決策。 這是通過在資源服務器上啟用能夠與授權服務器進行通信，請求授權數據並基於服務器返回的決策和權限來控制對受保護資源的訪問的政策服務器或PEP來實現的。 Keycloak提供了一些內置的Policy Enforcer實施，具體取決其運行的平台。 keycloak授權服務keycloak授權服務由以下RESTFul端點組成: 令牌端點(Token Endpoint) 資源管理端點(Resource Management Endpoint) 權限管理端點(Permission Management Endpoint) 每個服務都提供一個特定的API，涵蓋授權過程中涉及的不同步驟。 令牌端點(Token Endpoint) 一般熟知的Oauth流程 OAuth2客戶端(例如前端應用程序)可以使用令牌端點從服務器獲取訪問令牌，並使用這些相同的令牌來訪問受資源服務器保護的資源(例如後端服務)。 以相同的方式，Keycloak授權服務提供OAuth2的擴展，以允許基於與所請求的資源或範圍相關聯的所有策略的處理來發出訪問令牌。 這意味著資源服務器可以基於服務器授予的訪問令牌所擁有的權限來強制對其受保護資源的訪問。在Keycloak授權服務中，具有權限的訪問令牌稱為請求方令牌(Requesting Party Token)。 Protection APIProtection API是一組符UMA的端點，為資源服務器提供操作，以幫助他們管理與之關聯的資源，範圍，權限和策略。只允許資源服務器訪問此API，這也需要uma_protection範圍。 Protection API提供的操作可以分為兩大類： 資源管理(Resource Management) 創建資源(Create Resource) 刪除資源(Delete Resource) 按ID查找(Find by Id) 詢問(Query) 權限管理端點(Permission Management) 發行許可票(Issue Permission Tickets) 默認情況下，遠程資源管理為啟用狀態。您可以使用Keycloak管理控制台進行更改，並且僅允許通過控制台進行資源管理。 實例演練以下是我們要設置的方案: 新建一個Realm: authorization-demo 在此Realm下，新建一個Client: bank-client 定義一個/account/{id}為該Client下的一個Resource 在/account/{id}這個Resource下，有此 account::view Scope 建立一個User: bob 建立三個角色: bank_teller、account_owner和user 我們將設置以下兩個Role-base policies: bank_teller跟account_owner有權訪問/account/{id} Resource account_owner有權使用account:viewScope user 無權訪問任何Resource或Scope 使用keycloak內建的Evaluate工具來測試授予或拒絕訪問權限。 配置Keycloak基本配置內容可參閱上篇文章 建立Realm 將鼠標停在左上master，然後單擊Add Realm按鈕。 輸入authorization-demo作為名稱。 點擊Create。 確認左上角Realm在authorization-demo而不是master領域。 建立User 點擊左側的Users選單 點擊Add User按鈕 輸入username(例如bob) 確保User Enabled為開啟狀態 請點擊 Save 建立Roles 點擊左側的Roles選單 點擊Add Role 添加下列角色：bank_teller，account_owner和user 建立Client 點擊左側的Clients選單 點擊 Create Client ID欄位輸入bank-api Root URL欄位輸入http://127.0.0.1:8000/bank-api 點擊Save 確保Client Protocol是openid-connect 更改Access Type為confidential 更改Authorization Enabled為On 向下滾動並點擊Save。Authorization應會顯示在上方 點擊Authorization選項，然後再點擊Settings 確保將Decision Strategy設置為Unanimous 這是 Resource server 的 Decision Strategy (決策策略) (補充) Decision Strategy This configurations changes how the policy evaluation engine decides whether or not a resource or scope should be granted based on the outcome from all evaluated permissions. Affirmative means that at least one permission must evaluate to a positive decision in order grant access to a resource and its scopes. Unanimous means that all permissions must evaluate to a positive decision in order for the final decision to be also positive. As an example, if two permissions for a same resource or scope are in conflict (one of them is granting access and the other is denying access), the permission to the resource or scope will be granted if the choosen strategy is Affirmative. Otherwise, a single deny from any permission will also deny access to the resource or scope. 建立自定義Scope 點擊Authorization標籤 點擊Authorization Scopes &rarr; Create彈出Add Scope頁面 輸入account:view名稱，然後按Save。 建立自定義Resouce 點擊Authorization標籤 點擊 Resources 點擊 Create Name和Display name輸入View Account Resource URI輸入/account/{id} 在Scopes輸入account:view 點擊Save 更多內容可參閱Create Resources 建立Policies(重要)Create Only Bank Teller and Account Owner Policy 在Authorization標籤下，點擊Policies 從Create Policy下拉選單中選擇Role 在Name輸入Only Bank Teller and Account Owner Policy 在Realm Roles選擇bank_teller和account_owner角色並加入 確保Logic設置為Positive 請點擊 Save Create Only Account Owner Policy 再次點擊Policies 再次從Create Policy下拉選單中選擇Role 這次在Name輸入Only Account Owner Policy 這次在Realm Roles下選擇account_owner 確保Logic設置為Positive 請點擊 Save 更多內容請參閱Role-Based Policy 其他Policy可參閱Managing Policies 建立 Resource-Based Permission 再次在Authorization標籤下，點擊Permissions 選擇 Resource-Based Name欄位輸入View Account Resource Permission Resources欄位輸入View Account Resource Apply Policy下Only Bank Teller and Account Owner Policy 確保Decision Strategy設置為Unanimous 點擊Save Evaluating the Resource-Based permission 再次在Authorization標籤下，選擇Evaluate 在User輸入bob 在Roles選擇user 我們在這將User與我們創建的Role做關聯。 在Resources下選擇View Account Resource，然後點擊Add 點擊Evaluate 展開View Account Resource with scopes [account:view]以查看結果，應該看到DENY。 此部份的驗證是對的，因為在上方我們建立的一個只允許兩個角色訪問該Resource: Only Bank Teller and Account Owner PolicyPolicy 點擊Back回到Evaluate頁面 將bob的角色更改為account_owner，然後點擊Evaluate。現在，應該看到結果為PERMIT。將角色更改為bank_teller，也是同樣結果。 更多內容請參閱Evaluating and Testing Policies 建立 Scope-Based Permission 返回Permissions標籤 在Create Permission下拉選單中選擇Scope-Based Name輸入View Account Scope Permission Scopes輸入account:view Apply Policy輸入Only Account Owner Policy 確保Decision Strategy設置為Unanimous 點擊Save 更多內容請參閱Creating Scope-Based Permissions Evaluating the Scope-Based permission 再次點擊Evaluate標籤 在User輸入bob 在Roles選擇bank_teller 在Resources下選擇View Account Resource，然後點擊Add 點擊Evaluate，得到DENY 因為設置了bank_teller只可以訪問resource但不能訪問scope 且Resource server的Decision Strategy設置為Unanimous，最後的決定是DENY。(訪問resource評估為true，但訪問scope評估為false，所以得到DENY) 回到Authorization下的Settings，然後將更Decision Strategy改為Affirmative，然後再次返回到步驟1-5。這次最終結果應該是PERMIT（其中一個權限為true，所以最終結果為true）。 為了完整起見，將resource server的Decision Strategy重新設置為Unanimous。重新實施步驟1至5，但這一次將角色設置為account_owner。鑑於account_owner可以同時訪問resource和scope，所以這次的結果PERMIT。 結論說明authorization policies原理，以及透過實例來建制流程 先定義好scope 再建立resource，再把resource跟scope建立關聯 再建立policy(Role-Based、User-Based…)把resource與此policy關聯起來 再建立Resource-Based Permission or Scope-Based Permission。把 Policy與resource or scope關聯起來 參考資料 https://www.keycloak.org/docs/latest/authorization_services/index.html https://stackoverflow.com/questions/42186537/resources-scopes-permissions-and-policies-in-keycloak","link":"/2021/01/11/keycloak-authorization-services/"}],"tags":[{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"keycloak","slug":"keycloak","link":"/tags/keycloak/"}],"categories":[]}